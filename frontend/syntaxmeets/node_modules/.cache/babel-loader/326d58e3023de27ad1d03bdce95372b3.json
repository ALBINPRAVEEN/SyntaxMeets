{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _LazyPoint = require('./LazyPoint');\n\nvar _LazyPoint2 = _interopRequireDefault(_LazyPoint);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar RADIUS_DEFAULT = 30;\n\nvar LazyBrush = function () {\n  /**\r\n   * constructor\r\n   *\r\n   * @param {object} settings\r\n   * @param {number} settings.radius The radius for the lazy area\r\n   * @param {boolean} settings.enabled\r\n   */\n  function LazyBrush() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$radius = _ref.radius,\n        radius = _ref$radius === undefined ? RADIUS_DEFAULT : _ref$radius,\n        _ref$enabled = _ref.enabled,\n        enabled = _ref$enabled === undefined ? true : _ref$enabled,\n        _ref$initialPoint = _ref.initialPoint,\n        initialPoint = _ref$initialPoint === undefined ? {\n      x: 0,\n      y: 0\n    } : _ref$initialPoint;\n\n    _classCallCheck(this, LazyBrush);\n\n    this.radius = radius;\n    this._isEnabled = enabled;\n    this.pointer = new _LazyPoint2.default(initialPoint.x, initialPoint.y);\n    this.brush = new _LazyPoint2.default(initialPoint.x, initialPoint.y);\n    this.angle = 0;\n    this.distance = 0;\n    this._hasMoved = false;\n  }\n  /**\r\n   * Enable lazy brush calculations.\r\n   *\r\n   */\n\n\n  _createClass(LazyBrush, [{\n    key: 'enable',\n    value: function enable() {\n      this._isEnabled = true;\n    }\n    /**\r\n     * Disable lazy brush calculations.\r\n     *\r\n     */\n\n  }, {\n    key: 'disable',\n    value: function disable() {\n      this._isEnabled = false;\n    }\n    /**\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: 'isEnabled',\n    value: function isEnabled() {\n      return this._isEnabled;\n    }\n    /**\r\n     * Update the radius\r\n     *\r\n     * @param {number} radius\r\n     */\n\n  }, {\n    key: 'setRadius',\n    value: function setRadius(radius) {\n      this.radius = radius;\n    }\n    /**\r\n     * Return the current radius\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: 'getRadius',\n    value: function getRadius() {\n      return this.radius;\n    }\n    /**\r\n     * Return the brush coordinates as a simple object\r\n     *\r\n     * @returns {object}\r\n     */\n\n  }, {\n    key: 'getBrushCoordinates',\n    value: function getBrushCoordinates() {\n      return this.brush.toObject();\n    }\n    /**\r\n     * Return the pointer coordinates as a simple object\r\n     *\r\n     * @returns {object}\r\n     */\n\n  }, {\n    key: 'getPointerCoordinates',\n    value: function getPointerCoordinates() {\n      return this.pointer.toObject();\n    }\n    /**\r\n     * Return the brush as a LazyPoint\r\n     *\r\n     * @returns {LazyPoint}\r\n     */\n\n  }, {\n    key: 'getBrush',\n    value: function getBrush() {\n      return this.brush;\n    }\n    /**\r\n     * Return the pointer as a LazyPoint\r\n     *\r\n     * @returns {LazyPoint}\r\n     */\n\n  }, {\n    key: 'getPointer',\n    value: function getPointer() {\n      return this.pointer;\n    }\n    /**\r\n     * Return the angle between pointer and brush\r\n     *\r\n     * @returns {number} Angle in radians\r\n     */\n\n  }, {\n    key: 'getAngle',\n    value: function getAngle() {\n      return this.angle;\n    }\n    /**\r\n     * Return the distance between pointer and brush\r\n     *\r\n     * @returns {number} Distance in pixels\r\n     */\n\n  }, {\n    key: 'getDistance',\n    value: function getDistance() {\n      return this.distance;\n    }\n    /**\r\n     * Return if the previous update has moved the brush.\r\n     *\r\n     * @returns {boolean} Whether the brush moved previously.\r\n     */\n\n  }, {\n    key: 'brushHasMoved',\n    value: function brushHasMoved() {\n      return this._hasMoved;\n    }\n    /**\r\n     * Updates the pointer point and calculates the new brush point.\r\n     *\r\n     * @param {Point} newPointerPoint\r\n     * @param {Object} options\r\n     * @param {Boolean} options.both Force update pointer and brush\r\n     * @returns {Boolean} Whether any of the two points changed\r\n     */\n\n  }, {\n    key: 'update',\n    value: function update(newPointerPoint) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$both = _ref2.both,\n          both = _ref2$both === undefined ? false : _ref2$both;\n\n      this._hasMoved = false;\n\n      if (this.pointer.equalsTo(newPointerPoint) && !both) {\n        return false;\n      }\n\n      this.pointer.update(newPointerPoint);\n\n      if (both) {\n        this._hasMoved = true;\n        this.brush.update(newPointerPoint);\n        return true;\n      }\n\n      if (this._isEnabled) {\n        this.distance = this.pointer.getDistanceTo(this.brush);\n        this.angle = this.pointer.getAngleTo(this.brush);\n\n        if (this.distance > this.radius) {\n          this.brush.moveByAngle(this.angle, this.distance - this.radius);\n          this._hasMoved = true;\n        }\n      } else {\n        this.distance = 0;\n        this.angle = 0;\n        this.brush.update(newPointerPoint);\n        this._hasMoved = true;\n      }\n\n      return true;\n    }\n  }]);\n\n  return LazyBrush;\n}();\n\nexports.default = LazyBrush;","map":{"version":3,"sources":["C:/Users/akash/Desktop/Project/React/SyntaxMeets/frontend/syntaxmeets/node_modules/lazy-brush/lib/LazyBrush.js"],"names":["Object","defineProperty","exports","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","_LazyPoint","require","_LazyPoint2","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","TypeError","RADIUS_DEFAULT","LazyBrush","_ref","arguments","undefined","_ref$radius","radius","_ref$enabled","enabled","_ref$initialPoint","initialPoint","x","y","_isEnabled","pointer","brush","angle","distance","_hasMoved","enable","disable","isEnabled","setRadius","getRadius","getBrushCoordinates","toObject","getPointerCoordinates","getBrush","getPointer","getAngle","getDistance","brushHasMoved","update","newPointerPoint","_ref2","_ref2$both","both","equalsTo","getDistanceTo","getAngleTo","moveByAngle"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nvar _LazyPoint = require('./LazyPoint');\r\n\r\nvar _LazyPoint2 = _interopRequireDefault(_LazyPoint);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\nvar RADIUS_DEFAULT = 30;\r\n\r\nvar LazyBrush = function () {\r\n  /**\r\n   * constructor\r\n   *\r\n   * @param {object} settings\r\n   * @param {number} settings.radius The radius for the lazy area\r\n   * @param {boolean} settings.enabled\r\n   */\r\n  function LazyBrush() {\r\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\r\n        _ref$radius = _ref.radius,\r\n        radius = _ref$radius === undefined ? RADIUS_DEFAULT : _ref$radius,\r\n        _ref$enabled = _ref.enabled,\r\n        enabled = _ref$enabled === undefined ? true : _ref$enabled,\r\n        _ref$initialPoint = _ref.initialPoint,\r\n        initialPoint = _ref$initialPoint === undefined ? { x: 0, y: 0 } : _ref$initialPoint;\r\n\r\n    _classCallCheck(this, LazyBrush);\r\n\r\n    this.radius = radius;\r\n    this._isEnabled = enabled;\r\n\r\n    this.pointer = new _LazyPoint2.default(initialPoint.x, initialPoint.y);\r\n    this.brush = new _LazyPoint2.default(initialPoint.x, initialPoint.y);\r\n\r\n    this.angle = 0;\r\n    this.distance = 0;\r\n    this._hasMoved = false;\r\n  }\r\n\r\n  /**\r\n   * Enable lazy brush calculations.\r\n   *\r\n   */\r\n\r\n\r\n  _createClass(LazyBrush, [{\r\n    key: 'enable',\r\n    value: function enable() {\r\n      this._isEnabled = true;\r\n    }\r\n\r\n    /**\r\n     * Disable lazy brush calculations.\r\n     *\r\n     */\r\n\r\n  }, {\r\n    key: 'disable',\r\n    value: function disable() {\r\n      this._isEnabled = false;\r\n    }\r\n\r\n    /**\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: 'isEnabled',\r\n    value: function isEnabled() {\r\n      return this._isEnabled;\r\n    }\r\n\r\n    /**\r\n     * Update the radius\r\n     *\r\n     * @param {number} radius\r\n     */\r\n\r\n  }, {\r\n    key: 'setRadius',\r\n    value: function setRadius(radius) {\r\n      this.radius = radius;\r\n    }\r\n\r\n    /**\r\n     * Return the current radius\r\n     *\r\n     * @returns {number}\r\n     */\r\n\r\n  }, {\r\n    key: 'getRadius',\r\n    value: function getRadius() {\r\n      return this.radius;\r\n    }\r\n\r\n    /**\r\n     * Return the brush coordinates as a simple object\r\n     *\r\n     * @returns {object}\r\n     */\r\n\r\n  }, {\r\n    key: 'getBrushCoordinates',\r\n    value: function getBrushCoordinates() {\r\n      return this.brush.toObject();\r\n    }\r\n\r\n    /**\r\n     * Return the pointer coordinates as a simple object\r\n     *\r\n     * @returns {object}\r\n     */\r\n\r\n  }, {\r\n    key: 'getPointerCoordinates',\r\n    value: function getPointerCoordinates() {\r\n      return this.pointer.toObject();\r\n    }\r\n\r\n    /**\r\n     * Return the brush as a LazyPoint\r\n     *\r\n     * @returns {LazyPoint}\r\n     */\r\n\r\n  }, {\r\n    key: 'getBrush',\r\n    value: function getBrush() {\r\n      return this.brush;\r\n    }\r\n\r\n    /**\r\n     * Return the pointer as a LazyPoint\r\n     *\r\n     * @returns {LazyPoint}\r\n     */\r\n\r\n  }, {\r\n    key: 'getPointer',\r\n    value: function getPointer() {\r\n      return this.pointer;\r\n    }\r\n\r\n    /**\r\n     * Return the angle between pointer and brush\r\n     *\r\n     * @returns {number} Angle in radians\r\n     */\r\n\r\n  }, {\r\n    key: 'getAngle',\r\n    value: function getAngle() {\r\n      return this.angle;\r\n    }\r\n\r\n    /**\r\n     * Return the distance between pointer and brush\r\n     *\r\n     * @returns {number} Distance in pixels\r\n     */\r\n\r\n  }, {\r\n    key: 'getDistance',\r\n    value: function getDistance() {\r\n      return this.distance;\r\n    }\r\n\r\n    /**\r\n     * Return if the previous update has moved the brush.\r\n     *\r\n     * @returns {boolean} Whether the brush moved previously.\r\n     */\r\n\r\n  }, {\r\n    key: 'brushHasMoved',\r\n    value: function brushHasMoved() {\r\n      return this._hasMoved;\r\n    }\r\n\r\n    /**\r\n     * Updates the pointer point and calculates the new brush point.\r\n     *\r\n     * @param {Point} newPointerPoint\r\n     * @param {Object} options\r\n     * @param {Boolean} options.both Force update pointer and brush\r\n     * @returns {Boolean} Whether any of the two points changed\r\n     */\r\n\r\n  }, {\r\n    key: 'update',\r\n    value: function update(newPointerPoint) {\r\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\r\n          _ref2$both = _ref2.both,\r\n          both = _ref2$both === undefined ? false : _ref2$both;\r\n\r\n      this._hasMoved = false;\r\n      if (this.pointer.equalsTo(newPointerPoint) && !both) {\r\n        return false;\r\n      }\r\n\r\n      this.pointer.update(newPointerPoint);\r\n\r\n      if (both) {\r\n        this._hasMoved = true;\r\n        this.brush.update(newPointerPoint);\r\n        return true;\r\n      }\r\n\r\n      if (this._isEnabled) {\r\n        this.distance = this.pointer.getDistanceTo(this.brush);\r\n        this.angle = this.pointer.getAngleTo(this.brush);\r\n\r\n        if (this.distance > this.radius) {\r\n          this.brush.moveByAngle(this.angle, this.distance - this.radius);\r\n          this._hasMoved = true;\r\n        }\r\n      } else {\r\n        this.distance = 0;\r\n        this.angle = 0;\r\n        this.brush.update(newPointerPoint);\r\n        this._hasMoved = true;\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }]);\r\n\r\n  return LazyBrush;\r\n}();\r\n\r\nexports.default = LazyBrush;"]},"metadata":{},"sourceType":"script"}